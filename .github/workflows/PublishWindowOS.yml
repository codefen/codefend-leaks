name: WindowsBuildAndRelease

on:
  workflow_call:
    inputs:
      release_id:
        required: true
        type: string
      package_version:
        required: true
        type: string
      release_upload_url:
        required: true
        type: string
    outputs:
      windows_x86_64_sig:
        description: "Signature for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_sig }}
      windows_x86_64_name:
        description: "Name for Windows x86_64 build"
        value: ${{ jobs.windowsBuilding.outputs.windows_x86_64_name }}
  workflow_dispatch:


jobs:
  windowsBuilding:
    if: github.event.repository.fork == false
    name: BuildWindows
    permissions:
      contents: write
      id-token: write
      security-events: write
      attestations: write
    env:
      USE_ESIGNER: ${{ secrets.SSLCOM_USE_ESIGNER }}
    outputs:
      windows_x86_64_sig: ${{ steps.extract-signatures.outputs.windows_x86_64_sig }}
      windows_x86_64_name: ${{ steps.extract-signatures.outputs.windows_x86_64_name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-pc-windows-msvc
            arch: x64
            platform: windows/x86_64

    runs-on: windows-latest
    steps:
      - name: ðŸ”„ Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: ðŸ› ï¸ Setup/ Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: ðŸ› ï¸ Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: ðŸ› ï¸ Install dependencies
        run: bun install

      - name: ðŸŒ Export GitHub Actions cache environment variables windows
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      - name: ðŸ”§ Install system dependencies
        run: |
          echo "VCPKG_ROOT=$env:VCPKG_INSTALLATION_ROOT" | Out-File -FilePath $env:GITHUB_ENV -Append
          choco install wget -y
        env:
          VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

      - name: ðŸ¦€ Install rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: ðŸ“¦ Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          cache-on-failure: true
          shared-key: windows-release-${{ matrix.platform }}
          save-if: true

      - name: âœï¸ Create production environment file
        shell: pwsh
        run: |
          @"
          VITE_PORT=5173
          TAURI_PLATFORM=${{ matrix.platform }}
          VITE_NODE_ENV=production
          VITE_DEBUG=false
          VITE_APP_ENV=production
          VITE_ENABLE_GOOGLE_AUTH=false
          VITE_API_URI=https://api.codefend.com/index.php
          "@ | Out-File -FilePath .env -Encoding UTF8

      - name: â˜• Setup Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: ðŸ“¦ Cache CodeSignTool
        id: cache-codesigntool
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/codesigntool
          key: codesigntool-windows-v1.3.0
          restore-keys: codesigntool-windows-

      - name: ðŸ“¥ Download CodeSignTool
        if: steps.cache-codesigntool.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri "https://www.ssl.com/download/codesigntool-for-windows/" -OutFile "CodeSignTool.zip"
          Expand-Archive -Path "CodeSignTool.zip" -DestinationPath "$env:GITHUB_WORKSPACE\codesigntool" -Force

      - name: ðŸ” Locate CodeSignTool
        id: locate-codesigntool
        shell: pwsh
        run: |
          $batFile = Get-ChildItem -Path "$env:GITHUB_WORKSPACE\codesigntool" -Filter "CodeSignTool*.bat" -Recurse | Select-Object -First 1
          if (-not $batFile) {
            Write-Error "âŒ CodeSignTool.bat not found"
            exit 1
          }
          $batDir = Split-Path -Parent $batFile.FullName
          echo "CODESIGNTOOL_DIR=$batDir" >> $env:GITHUB_OUTPUT

      - name: ðŸ”¨ Build frontend
        run: bun run build

      - name: ðŸ”¨ðŸ” Build and Sign with Tauri
        shell: pwsh
        env:
          RUSTFLAGS: "-C target-feature=+crt-static"
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          TAURI_BUNDLE_IDENTIFIER: "codefend.leaks"
          TAURI_BUNDLE_VERSION: ${{ inputs.package_version }}
          SSL_USERNAME: ${{ secrets.SSLCOM_USERNAME }}
          SSL_PASSWORD: ${{ secrets.SSLCOM_PASSWORD }}
          CREDENTIAL_ID: ${{ secrets.SSLCOM_CREDENTIAL_ID }}
          SSL_TOTP_SECRET: ${{ secrets.SSLCOM_TOTP_SECRET }}
          CODESIGNTOOL_DIR: ${{ steps.locate-codesigntool.outputs.CODESIGNTOOL_DIR }}
        run: |
          cd src-tauri
          bun x --yes @tauri-apps/cli@latest build --bundles nsis,msi --verbose
          cd ..

      - name: âœ… Verify all signatures
        shell: pwsh
        run: |
          $allFiles = @()
          $allFiles += Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          $allFiles += Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          $allFiles += Get-Item ".\src-tauri\target\release\codefend-leaks.exe" -ErrorAction SilentlyContinue

          if ($allFiles.Count -eq 0) {
            Write-Error "âŒ No se encontraron archivos para verificar"
            exit 1
          }

          $allValid = $true

          foreach ($file in $allFiles) {
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            Write-Host "`nðŸ“„ $($file.Name): $($sig.Status)"

            if ($sig.Status -eq "Valid") {
              Write-Host "   âœ… Firmado por: $($sig.SignerCertificate.Subject)" -ForegroundColor Green
            } else {
              Write-Host "   âŒ FIRMA INVÃLIDA: $($sig.StatusMessage)" -ForegroundColor Red
              $allValid = $false
            }
          }

          if (-not $allValid) {
            Write-Error "`nâŒ Algunos archivos no estÃ¡n firmados correctamente"
            exit 1
          }

      - name: ðŸ” Generate Tauri updater .sig files
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: |
          Write-Host "ðŸ” Generando archivos .sig para el updater..."
          $artifacts = @()
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $artifacts += Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue

          if ($artifacts.Count -eq 0) {
            Write-Error "âŒ No se encontraron artefactos"
            exit 1
          }

          foreach ($artifact in $artifacts) {
            Write-Host "ðŸ–Šï¸  Generando firma Tauri para: $($artifact.Name)"

            $bunArgs = @(
              "x", "--yes", "@tauri-apps/cli@latest", "signer", "sign",
              "--private-key", "$env:TAURI_SIGNING_PRIVATE_KEY",
              "--password", "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD",
              "`"$($artifact.FullName)`""
            )

            & bun @bunArgs

            if ($LASTEXITCODE -ne 0) {
              Write-Error "âŒ Error generando .sig para $($artifact.Name)"
              exit 1
            }

            $expectedSig = "$($artifact.FullName).sig"
            if (-not (Test-Path $expectedSig)) {
              Write-Error "âŒ No se generÃ³ el archivo .sig: $expectedSig"
              exit 1
            }
          }

      # - name: ðŸ” Debug - List files before upload
      #   shell: pwsh
      #   run: |
      #     Write-Host "=== Files in bundle directories ==="
      #     Write-Host "`nðŸ“ MSI files:"
      #     Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -ErrorAction SilentlyContinue | ForEach-Object {
      #       Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
      #     }
      #     Write-Host "`nðŸ“ NSIS files:"
      #     Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -ErrorAction SilentlyContinue | ForEach-Object {
      #       Write-Host "  - $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
      #     }
      #     Write-Host "===================================="

      - name: ðŸ“¤ Upload signed artifacts to release
        if: inputs.release_id != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $tag = "codefend-leaks-v${{ inputs.package_version }}"
          $repo = "$env:GITHUB_REPOSITORY"

          $artifacts = @()
          $msiFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }
          $exeFiles = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" }

          if ($msiFiles) { $artifacts += $msiFiles }
          if ($exeFiles) { $artifacts += $exeFiles }

          if ($artifacts.Count -eq 0) {
            Write-Error "âŒ No se encontraron archivos .msi o .exe para subir"
            exit 1
          }

          foreach ($artifact in $artifacts) {
            Write-Host "`nðŸ“¤ Subiendo: $($artifact.Name) ($([math]::Round($artifact.Length/1MB, 2)) MB)"

            try {
              gh release upload $tag "$($artifact.FullName)" --repo $repo --clobber
              Write-Host "âœ… Archivo subido exitosamente"
            } catch {
              Write-Error "âŒ Error subiendo $($artifact.Name): $($_.Exception.Message)"
              exit 1
            }
          }

      - name: ðŸ“¤ Upload signed artifacts to workflow
        uses: actions/upload-artifact@v4
        with:
          name: signed-windows-binaries
          path: |
            src-tauri/target/release/bundle/msi/*.msi
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/msi/*.sig
            src-tauri/target/release/bundle/nsis/*.sig
          retention-days: 7

      - name: ðŸ“ Extract signatures for outputs
        id: extract-signatures
        shell: pwsh
        run: |
          # Seleccionar artefacto principal (MSI preferido; si no, EXE)
          $msiFile = Get-ChildItem -Path ".\src-tauri\target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" } | Select-Object -First 1
          $exeFile = Get-ChildItem -Path ".\src-tauri\target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.Name -notlike "*.sig" } | Select-Object -First 1

          $artifact = $msiFile
          $artifactType = "MSI"
          if (-not $artifact) {
            $artifact = $exeFile
            $artifactType = "EXE"
          }

          if (-not $artifact) {
            Write-Error "âŒ No se encontrÃ³ artefacto MSI o EXE para extraer firma"
            Write-Host "Buscando archivos en directorios:"
            Get-ChildItem -Path ".\src-tauri\target\release\bundle" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "  $($_.FullName)"
            }
            exit 1
          }

          $sigFile = "$($artifact.FullName).sig"
          if (-not (Test-Path $sigFile)) {
            Write-Error "âŒ No se encontrÃ³ archivo .sig para $($artifact.Name)"
            Write-Error "   Buscado en: $sigFile"
            exit 1
          }

          # Leer firma
          $signature = (Get-Content -Raw -Path $sigFile).Trim()

          if ([string]::IsNullOrWhiteSpace($signature)) {
            Write-Error "âŒ El archivo .sig estÃ¡ vacÃ­o"
            exit 1
          }

          # Exportar outputs
          echo "windows_x86_64_sig=$signature" >> $env:GITHUB_OUTPUT
          echo "windows_x86_64_name=$($artifact.Name)" >> $env:GITHUB_OUTPUT

      - name: ðŸ§¹ Cleanup temporary files
        if: always()
        shell: pwsh
        run: |
          # Limpiar directorios temporales
          @("codesigntool", "signed", "signed-app") | ForEach-Object {
            if (Test-Path "$env:GITHUB_WORKSPACE\$_") {
              Remove-Item -Path "$env:GITHUB_WORKSPACE\$_" -Recurse -Force
            }
          }

          # Limpiar archivo ZIP
          if (Test-Path "CodeSignTool.zip") {
            Remove-Item "CodeSignTool.zip" -Force
          }
